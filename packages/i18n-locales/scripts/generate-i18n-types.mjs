/**
 * Generate static TypeScript types from English translation JSON files
 * Node-compatible ESM script for CI/CD environments.
 */

import { readdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const projectRoot = join(__dirname, "..");
const LOCALES_DIR = join(projectRoot, "src", "locales", "en");
const LOCALES_ROOT_DIR = join(projectRoot, "src", "locales");
const OUTPUT_FILE = join(projectRoot, "src", "types.d.ts");
const CONSTANTS_OUTPUT_FILE = join(projectRoot, "src", "constants.ts");

function toPascalCase(str) {
  return str
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");
}

function generateInterfaceFromJson(obj, indent = 0) {
  const spaces = "  ".repeat(indent);
  let result = "";

  for (const [key, value] of Object.entries(obj)) {
    if (Array.isArray(value)) {
      result += `${spaces}${key}: string[];\n`;
    } else if (typeof value === "object" && value !== null) {
      result += `${spaces}${key}: {\n`;
      result += generateInterfaceFromJson(value, indent + 1);
      result += `${spaces}};\n`;
    } else {
      result += `${spaces}${key}: string;\n`;
    }
  }

  return result;
}

function readJsonFile(filePath) {
  const content = readFileSync(filePath, "utf-8");
  return JSON.parse(content);
}

function getNamespaces() {
  const files = readdirSync(LOCALES_DIR);
  return files
    .filter((file) => file.endsWith(".json"))
    .map((file) => ({ file, namespace: file.replace(".json", "") }));
}

/**
 * Get all supported languages by scanning the locales directory
 */
function getSupportedLanguages() {
  const items = readdirSync(LOCALES_ROOT_DIR);
  return items
    .filter((item) => {
      const itemPath = join(LOCALES_ROOT_DIR, item);
      try {
        return readdirSync(itemPath).length > 0; // Has files
      } catch {
        return false; // Not a directory
      }
    })
    .sort(); // Alphabetical order
}

/**
 * Generate constants file with DEFAULT_LANGUAGE and SUPPORTED_LANGUAGES
 */
function generateConstants() {
  console.log("üîÑ Generating i18n constants...");

  const supportedLanguages = getSupportedLanguages();

  if (supportedLanguages.length === 0) {
    throw new Error(`No locale directories found in ${LOCALES_ROOT_DIR}`);
  }

  // DEFAULT_LANGUAGE is "en" if it exists, otherwise first alphabetically
  const defaultLanguage = supportedLanguages.includes("en")
    ? "en"
    : supportedLanguages[0];

  const constantsContent = `/**
 * Auto-generated language constants
 * Generated from: packages/i18n-locales/src/locales/*
 * DO NOT EDIT THIS FILE MANUALLY - Run 'bun run generate:i18n-types' to regenerate
 */

export const DEFAULT_LANGUAGE = "${defaultLanguage}" as const;

export const SUPPORTED_LANGUAGES = [
  ${supportedLanguages.map((lang) => `"${lang}"`).join(",\n  ")},
] as const;
`;

  writeFileSync(CONSTANTS_OUTPUT_FILE, constantsContent, "utf-8");

  console.log(`‚úÖ Generated constants at: ${CONSTANTS_OUTPUT_FILE}`);
  console.log(`üì¶ Default language: ${defaultLanguage}`);
  console.log(`üì¶ Supported languages: ${supportedLanguages.join(", ")}`);
}

function generateTypes() {
  console.log("üîÑ Generating i18n type definitions...");

  const namespaceList = getNamespaces();
  if (namespaceList.length === 0) {
    throw new Error(`No JSON files found in ${LOCALES_DIR}`);
  }

  const supportedLanguages = getSupportedLanguages();

  let typeDefinitions = `/**
 * Auto-generated TypeScript definitions for i18n translations
 * Generated from: packages/i18n-locales/src/locales/en/*.json
 * DO NOT EDIT THIS FILE MANUALLY - Run 'bun run generate:i18n-types' or 'npm run generate:i18n-types' to regenerate
 *
 * Type-safe translation system with full IntelliSense support
 * Supports generic type inference and static type checking
 */

/**
 * Supported language codes
 * Auto-generated from available locale directories
 */
export type SupportedLanguage =\n  | ${supportedLanguages.map((lang) => `"${lang}"`).join("\n  | ")};

`;

  const interfaceNames = [];

  for (const { file, namespace } of namespaceList) {
    const filePath = join(LOCALES_DIR, file);
    const json = readJsonFile(filePath);
    const pascalNamespace = toPascalCase(namespace);
    const interfaceName = `${pascalNamespace}Translations`;
    interfaceNames.push(interfaceName);

    typeDefinitions += `/**
 * Translations for ${namespace} namespace
 * Generated from: packages/i18n-locales/src/locales/en/${file}
 */\nexport interface ${interfaceName} {\n`;
    typeDefinitions += generateInterfaceFromJson(json, 1);
    typeDefinitions += `}\n\n`;
  }

  const baseInterface = interfaceNames.includes("CommonTranslations")
    ? "CommonTranslations"
    : interfaceNames[0];

  typeDefinitions += `/**
 * Complete namespace translation structure combining all translation namespaces
 * Provides full static typing for all translation keys
 */\nexport type AppNamespaceTranslations = ${baseInterface} & {\n`;

  for (const { namespace } of namespaceList) {
    if (namespace === "common") continue;
    const camelNamespace =
      namespace === "qr-generator"
        ? "qrGenerator"
        : namespace.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
    const interfaceName = toPascalCase(namespace) + "Translations";
    typeDefinitions += `  ${camelNamespace}: ${interfaceName};\n`;
  }

  typeDefinitions += `};\n\n`;

  typeDefinitions += `export type NamespaceTranslations = AppNamespaceTranslations;\n\n`;

  typeDefinitions += `/**
 * Type-safe key path helper for translation keys
 * Provides IntelliSense support for nested translation keys
 */
export type AppTranslationKeyPath<T extends object> = {
  [K in keyof T & string]: T[K] extends object
    ? \`\${K}.\${AppTranslationKeyPath<T[K]>}\`
    : K;
}[keyof T & string];

export type TranslationKeyPath<T extends object> = AppTranslationKeyPath<T>;

/**
 * Generic translation provider with static type support
 */
export type TranslationProvider<
  T extends AppNamespaceTranslations = AppNamespaceTranslations,
> = {
  get<K extends TranslationKeyPath<T>>(
    key: K,
    params?: Record<string, string | number>,
  ): string;
  has(key: string): boolean;
};

/**
 * Global ambient type declaration for NamespaceTranslations
 * Available globally without imports
 */
declare global {
  type NamespaceTranslations = AppNamespaceTranslations;
  type TranslationKeyPath = AppTranslationKeyPath<AppNamespaceTranslations>;
}
`;

  writeFileSync(OUTPUT_FILE, typeDefinitions, "utf-8");

  console.log(`‚úÖ Generated type definitions at: ${OUTPUT_FILE}`);
  console.log(`üì¶ Detected ${namespaceList.length} translation namespaces`);
  console.log(`üì¶ Bundle size improvement: No runtime JSON imports in types!`);
}

try {
  generateConstants();
  generateTypes();
} catch (error) {
  console.error("‚ùå Error generating i18n types:", error);
  process.exit(1);
}
