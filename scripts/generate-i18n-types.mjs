/**
 * Generate static TypeScript types from English translation JSON files
 * Node-compatible ESM script for CI/CD environments.
 */

import { readdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";

const LOCALES_DIR = join(process.cwd(), "app", "locales", "en");
const OUTPUT_FILE = join(
  process.cwd(),
  "app",
  "lib",
  "i18n",
  "types",
  "generated-translations.d.ts",
);

function toPascalCase(str) {
  return str
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");
}

function generateInterfaceFromJson(obj, indent = 0) {
  const spaces = "  ".repeat(indent);
  let result = "";

  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      result += `${spaces}${key}: {\n`;
      result += generateInterfaceFromJson(value, indent + 1);
      result += `${spaces}};\n`;
    } else {
      result += `${spaces}${key}: string;\n`;
    }
  }

  return result;
}

function readJsonFile(filePath) {
  const content = readFileSync(filePath, "utf-8");
  return JSON.parse(content);
}

function getNamespaces() {
  const files = readdirSync(LOCALES_DIR);
  return files
    .filter((file) => file.endsWith(".json"))
    .map((file) => ({ file, namespace: file.replace(".json", "") }));
}

function generateTypes() {
  console.log("üîÑ Generating i18n type definitions...");

  const namespaceList = getNamespaces();
  if (namespaceList.length === 0) {
    throw new Error(`No JSON files found in ${LOCALES_DIR}`);
  }

  let typeDefinitions = `/**
 * Auto-generated TypeScript definitions for i18n translations
 * Generated from: app/locales/en/*.json
 * DO NOT EDIT THIS FILE MANUALLY - Run 'bun run generate:i18n-types' or 'npm run generate:i18n-types' to regenerate
 * \n * Type-safe translation system with full IntelliSense support
 * Supports generic type inference and static type checking
 */\n\n`;

  const interfaceNames = [];

  for (const { file, namespace } of namespaceList) {
    const filePath = join(LOCALES_DIR, file);
    const json = readJsonFile(filePath);
    const pascalNamespace = toPascalCase(namespace);
    const interfaceName = `${pascalNamespace}Translations`;
    interfaceNames.push(interfaceName);

    typeDefinitions += `/**
 * Translations for ${namespace} namespace
 * Generated from: app/locales/en/${file}
 */\nexport interface ${interfaceName} {\n`;
    typeDefinitions += generateInterfaceFromJson(json, 1);
    typeDefinitions += `}\n\n`;
  }

  const baseInterface = interfaceNames.includes("CommonTranslations")
    ? "CommonTranslations"
    : interfaceNames[0];

  typeDefinitions += `/**
 * Complete namespace translation structure combining all translation namespaces
 * Provides full static typing for all translation keys
 */\nexport type NamespaceTranslations = ${baseInterface} & {\n`;

  for (const { namespace } of namespaceList) {
    if (namespace === "common") continue;
    const camelNamespace =
      namespace === "qr-generator"
        ? "qrGenerator"
        : namespace.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
    const interfaceName = toPascalCase(namespace) + "Translations";
    typeDefinitions += `  ${camelNamespace}: ${interfaceName};\n`;
  }

  typeDefinitions += `};\n\n`;

  typeDefinitions += `/**
 * Type-safe key path helper for translation keys
 * Provides IntelliSense support for nested translation keys
 */\nexport type TranslationKeyPath<T extends object> = {\n  [K in keyof T]: T[K] extends object\n    ? \`\${K & string}.\${TranslationKeyPath<T[K]>}\`\n    : K;\n}[keyof T];\n\n/**
 * Generic translation provider with static type support
 */\nexport type TranslationProvider<T extends NamespaceTranslations = NamespaceTranslations> = {\n  get<K extends TranslationKeyPath<T>>(key: K, params?: Record<string, string | number>): string;\n  has(key: string): boolean;\n};\n\n/**
 * Global ambient type declaration for NamespaceTranslations
 * Available globally without imports
 */\ndeclare global {\n  type NamespaceTranslations = NamespaceTranslations;\n  type TranslationKeyPath = TranslationKeyPath<NamespaceTranslations>;\n}\n`;

  writeFileSync(OUTPUT_FILE, typeDefinitions, "utf-8");

  console.log(`‚úÖ Generated type definitions at: ${OUTPUT_FILE}`);
  console.log(`üì¶ Detected ${namespaceList.length} translation namespaces`);
  console.log(`üì¶ Bundle size improvement: No runtime JSON imports in types!`);
}

try {
  generateTypes();
} catch (error) {
  console.error("‚ùå Error generating i18n types:", error);
  process.exit(1);
}
