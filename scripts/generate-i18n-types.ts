#!/usr/bin/env bun
/**
 * Generate static TypeScript types from English translation JSON files
 * This script creates type definitions without importing actual JSON files,
 * reducing bundle size in the modular monolith architecture.
 */

import { readdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";

const LOCALES_DIR = join(process.cwd(), "app", "locales", "en");
const OUTPUT_FILE = join(
  process.cwd(),
  "app",
  "lib",
  "i18n",
  "types",
  "generated-translations.d.ts",
);

/**
 * Convert kebab-case to PascalCase for interface naming
 */
function toPascalCase(str: string): string {
  return str
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");
}

/**
 * Generate TypeScript interface from JSON object recursively with proper typing
 */
function generateInterfaceFromJson(
  obj: Record<string, unknown>,
  indent = 0,
): string {
  const spaces = "  ".repeat(indent);
  let result = "";

  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      result += `${spaces}${key}: {\n`;
      result += generateInterfaceFromJson(
        value as Record<string, unknown>,
        indent + 1,
      );
      result += `${spaces}};\n`;
    } else {
      result += `${spaces}${key}: string;\n`;
    }
  }

  return result;
}

/**
 * Read and parse JSON file with error handling
 */
function readJsonFile(filePath: string): Record<string, unknown> {
  const content = readFileSync(filePath, "utf-8");
  return JSON.parse(content) as Record<string, unknown>;
}

/**
 * Auto-detect namespace files from locales directory
 */
function getNamespaces(): Array<{ file: string; namespace: string }> {
  const files = readdirSync(LOCALES_DIR);
  return files
    .filter((file) => file.endsWith(".json"))
    .map((file) => ({
      file,
      namespace: file.replace(".json", ""),
    }));
}

/**
 * Generate type definitions for all translation namespaces
 * Supports TypeScript generics and static type inference
 */
function generateTypes(): void {
  console.log("üîÑ Generating i18n type definitions...");

  // Auto-detect namespace files
  const namespaceList = getNamespaces();

  if (namespaceList.length === 0) {
    throw new Error(`No JSON files found in ${LOCALES_DIR}`);
  }

  let typeDefinitions = `/**
 * Auto-generated TypeScript definitions for i18n translations
 * Generated from: app/locales/en/*.json
 * DO NOT EDIT THIS FILE MANUALLY - Run 'bun run generate:i18n-types' to regenerate
 * 
 * Type-safe translation system with full IntelliSense support
 * Supports generic type inference and static type checking
 */

`;

  // Generate individual interfaces for each namespace
  const interfaceNames: string[] = [];

  for (const { file, namespace } of namespaceList) {
    const filePath = join(LOCALES_DIR, file);
    const json = readJsonFile(filePath);
    const pascalNamespace = toPascalCase(namespace);
    const interfaceName = `${pascalNamespace}Translations`;

    interfaceNames.push(interfaceName);

    typeDefinitions += `/**
 * Translations for ${namespace} namespace
 * Generated from: app/locales/en/${file}
 */
export interface ${interfaceName} {\n`;
    typeDefinitions += generateInterfaceFromJson(json, 1);
    typeDefinitions += `}\n\n`;
  }

  // Generate the main NamespaceTranslations type with proper composition
  const commonIndex = interfaceNames.indexOf("CommonTranslations");
  const baseInterface =
    commonIndex >= 0 ? "CommonTranslations" : interfaceNames[0];
  const namespaceInterfaces = interfaceNames.filter((name) => name !== baseInterface);

  typeDefinitions += `/**
 * Complete namespace translation structure combining all translation namespaces
 * Provides full static typing for all translation keys
 */
export type NamespaceTranslations = ${baseInterface} & {\n`;

  for (const { namespace } of namespaceList) {
    if (namespace === "common") continue;
    const camelNamespace =
      namespace === "qr-generator"
        ? "qrGenerator"
        : namespace.replace(/-([a-z])/g, (_, char: string) => char.toUpperCase());
    const interfaceName = toPascalCase(namespace) + "Translations";
    typeDefinitions += `  ${camelNamespace}: ${interfaceName};\n`;
  }

  typeDefinitions += `};\n\n`;

  // Generate generic type helper for type-safe translation access
  typeDefinitions += `/**
 * Type-safe key path helper for translation keys
 * Provides IntelliSense support for nested translation keys
 */
export type TranslationKeyPath<T extends object> = {
  [K in keyof T]: T[K] extends object
    ? \`\${K & string}.\${TranslationKeyPath<T[K]>}\`
    : K;
}[keyof T];

/**
 * Generic translation provider with static type support
 */
export type TranslationProvider<T extends NamespaceTranslations = NamespaceTranslations> = {
  get<K extends TranslationKeyPath<T>>(key: K, params?: Record<string, string | number>): string;
  has(key: string): boolean;
};

/**
 * Global ambient type declaration for NamespaceTranslations
 * Available globally without imports
 */
declare global {
  type NamespaceTranslations = NamespaceTranslations;
  type TranslationKeyPath = TranslationKeyPath<NamespaceTranslations>;
}
`;

  // Write the generated types to file
  writeFileSync(OUTPUT_FILE, typeDefinitions, "utf-8");

  console.log(`‚úÖ Generated type definitions at: ${OUTPUT_FILE}`);
  console.log(`üì¶ Detected ${namespaceList.length} translation namespaces`);
  console.log(`üì¶ Bundle size improvement: No runtime JSON imports in types!`);
}

// Run the type generation
try {
  generateTypes();
} catch (error) {
  console.error("‚ùå Error generating i18n types:", error);
  process.exit(1);
}